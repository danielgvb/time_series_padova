# Generate cumulative predictions
pred_bm_f_d <- predict(bm_f_d, newx = c(1:length(food_d_ts)))
pred_bm_f_d <- ts(pred_bm_f_d, start = start(food_d_ts), frequency = frequency(food_d_ts))
# Calculate instantaneous predictions
pred.inst_bm_f_d <- make.instantaneous(pred_bm_f_d)
pred.inst_bm_f_d <- ts(pred.inst_bm_f_d, start = start(food_d_ts), frequency = frequency(food_d_ts))
# Plot of fitted model
# Plot actual vs fitted sales for daily data
plot(food_d_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Day", ylab = "Daily Sales", main = "Actual vs Fitted Daily Sales")
# Add fitted instantaneous sales
lines(pred.inst_bm_f_d, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# check residuals
res_bm_f_d <- food_d_ts - pred.inst_bm_f_d
tsdisplay(res_bm_f_d)
# residuals are not well behaved, seem not stationary and correlated
# overall the bass model fits a bell, if we are doing a generalized version
# lets try one that lets us define a more versatile curve
## 6.1.2 BASS Model BAR-----------------------------
### Monthly---------
# Simple Bass model for bar sales
bm_b_m <- BM(bar_m_ts, display = TRUE) # Show graphical view of results
summary(bm_b_m)
bm_b_m$coefficients['m'] - sum(bar_m_ts)
# According to this, there are only 237.148.750 COP left to sell, this is less than a year / seems wrong
# Prediction
pred_bm_b_m <- predict(bm_b_m, newx = c(1:length(bar_m_ts)))
pred_bm_b_m <- ts(pred_bm_b_m, start = start(bar_m_ts), frequency = frequency(bar_m_ts))
pred.inst_bm_b_m <- make.instantaneous(pred_bm_b_m)
pred.inst_bm_b_m <- ts(pred.inst_bm_b_m, start = start(bar_m_ts), frequency = frequency(bar_m_ts))
# Plot
plot(bar_m_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Monthly Sales", main = "Actual vs Fitted Sales (Bar)")
# Add the fitted values as a line
lines(pred.inst_bm_b_m, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Check residuals
res_bm_b_m <- bar_m_ts - pred.inst_bm_b_m
tsdisplay(res_bm_b_m)
# Residuals have some structure and 1 lag has correlation
### Weekly------------------------------------------------
bm_b_w <- BM(bar_w_ts, display = TRUE) # Show graphical view of results
summary(bm_b_w)
bm_b_w$coefficients['m'] - sum(bar_w_ts)
# Results are similar in terms of m, p and q are on another scale
# because they are in a different time stamp
bm_b_m$coefficients['q'] / bm_b_w$coefficients['q'] # They are approx 4 times
bm_b_m$coefficients['p'] / bm_b_w$coefficients['p'] # They are approx 4 times
# Which makes sense
# Prediction
pred_bm_b_w <- predict(bm_b_w, newx = c(1:length(bar_w_ts)))
pred_bm_b_w <- ts(pred_bm_b_w, start = start(bar_w_ts), frequency = frequency(bar_w_ts))
pred.inst_bm_b_w <- make.instantaneous(pred_bm_b_w)
pred.inst_bm_b_w <- ts(pred.inst_bm_b_w, start = start(bar_w_ts), frequency = frequency(bar_w_ts))
# Plot
plot(bar_w_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Week", ylab = "Weekly Sales", main = "Actual vs Fitted Sales (Bar)")
# Add the fitted values as a line
lines(pred.inst_bm_b_w, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Check residuals
res_bm_b_w <- bar_w_ts - pred.inst_bm_b_w
tsdisplay(res_bm_b_w)
# Clear trend and structure in the residuals
### Daily--------------
bm_b_d <- BM(bar_d_ts,method ='nls',
oos=round(length(bar_d_ts)*0.5), , display = TRUE) # Show graphical view of results
summary(bm_b_d)
# after serveral iterations, this model does not fit properly, and should not
# we will continue with GGM
bm_b_d$coefficients['m'] - sum(bar_d_ts)
# Results are similar in terms of m, p and q are on another scale
# because they are in a different time stamp
bm_b_w$coefficients['q'] / bm_b_d$coefficients['q'] # They are approx 7 times
bm_b_w$coefficients['p'] / bm_b_d$coefficients['p'] # They are approx 7 times
# Which makes sense
# Prediction
pred_bm_b_d <- predict(bm_b_d, newx = c(1:length(bar_d_ts)))
pred_bm_b_d <- ts(pred_bm_b_d, start = start(bar_d_ts), frequency = frequency(bar_d_ts))
# Calculate instantaneous predictions
pred.inst_bm_b_d <- make.instantaneous(pred_bm_b_d)
pred.inst_bm_b_d <- ts(pred.inst_bm_b_d, start = start(bar_d_ts), frequency = frequency(bar_d_ts))
# Plot
plot(bar_d_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Day", ylab = "Daily Sales", main = "Actual vs Fitted Daily Sales (Bar)")
# Add fitted instantaneous sales
lines(pred.inst_bm_b_d, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Check residuals
res_bm_b_d <- bar_d_ts - pred.inst_bm_b_d
tsdisplay(res_bm_b_d)
# Residuals are not well behaved, seem not stationary and correlated
# Overall the Bass model fits a bell, if we are doing a generalized version
# let's try one that lets us define a more versatile curve
## 6.1.3 GGM FOOD-------------
# Runs on DIMORA
# documentation: https://cran.rstudio.com/web/packages/DIMORA/DIMORA.pdf
# bass model preliminary m, p, q for algorithm
# mt argument is the determination of market potential
### Monthly----------------------------------
ggm1 <- GGM(food_m_ts, mt='base', display = T)
ggm2 <- GGM(food_m_ts, mt= function(x) pchisq(x,10),display = T)
summary(ggm1)
summary(ggm2)
# try different functions for market potential
ggm3 <- GGM(food_m_ts, mt= function(x) log(x),display = T)
ggm4 <- GGM(food_m_ts, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3)
summary(ggm4)
# predictions
pred_GGM_m<- predict(ggm1, newx=c(1:length(food_m_ts)))
pred_GGM_m<- ts(pred_GGM_m, start=start(food_m_ts), frequency = frequency(food_m_ts))
pred_GGM_m.inst<- make.instantaneous(pred_GGM_m)
pred_GGM_m.inst <- ts(pred_GGM_m.inst, start = start(food_m_ts), frequency=frequency(food_m_ts))
# plot
plot(food_m_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Monthly Sales", main = "Actual vs Fitted Sales")
# Add the fitted values as a line
lines(pred_GGM_m.inst, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
###Analysis of residuals
res_GGM_f_m<- food_m_ts - pred_GGM_m.inst
tsdisplay(res_GGM_f_m)
# Residuals somehow are kind of stationary
# check for stationarity of residuals
adf_test <- adf.test(res_GGM_f_m)
print(adf_test) # if p-val < alpha, series stationary
# so with this model we achieve stationary series
# check for autocorrelation in residuals
Box.test(res_GGM_f_m, lag = 10, type = "Ljung-Box") # h0 res indep
# p-val > alpha => fail to reject h0, so residuals seem indep
### Weekly----------------------------------
ggm1_w <- GGM(food_w_ts, mt='base', display = T)
ggm2_w <- GGM(food_w_ts, mt= function(x) pchisq(x,25),display = T)
summary(ggm1_w) # this one is better
summary(ggm2_w)
# try different functions for market potential
ggm3_w <- GGM(food_w_ts, mt= function(x) log(x),display = T)
ggm4_w <- GGM(food_w_ts, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3_w)
summary(ggm4_w) # better shaped but less significant
# predictions
pred_GGM_w<- predict(ggm1_w, newx=c(1:length(food_w_ts)))
pred_GGM_w<- ts(pred_GGM_w, start=start(food_w_ts), frequency = frequency(food_w_ts))
pred_GGM_w.inst<- make.instantaneous(pred_GGM_w)
pred_GGM_w.inst <- ts(pred_GGM_w.inst, start = start(food_w_ts), frequency=frequency(food_w_ts))
# plot
plot(food_w_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Weekly Sales", main = "Actual vs Fitted Sales")
# Add the fitted values as a line
lines(pred_GGM_w.inst, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
###Analysis of residuals
res_GGM_f_w<- food_w_ts - pred_GGM_w.inst
tsdisplay(res_GGM_f_w)
# residuals have correlation and structure
# Residuals somehow are kind of stationary
# check for stationarity of residuals
adf_test <- adf.test(res_GGM_f_w)
print(adf_test) # if p-val < alpha, series not stationary
# so with this model we dont achieve stationary series
# check for autocorrelation in residuals
Box.test(res_GGM_f_w, lag = 10, type = "Ljung-Box") # h0 res indep
# p-val < alpha =>  reject h0, so residuals are NOT indep
### Daily----------------------------------
ggm1_d <- GGM(food_d_ts, mt='base', display = T)
ggm2_d <- GGM(food_d_ts, mt= function(x) pchisq(x,10),display = T)
summary(ggm1_d) # this one is better looking
summary(ggm2_d)
# try different functions for market potential
ggm3_d <- GGM(food_d_ts, mt= function(x) log(x),display = T)
ggm4_d <- GGM(food_d_ts, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3_d)
summary(ggm1_d)
summary(ggm4_d) # better shaped and still significant
# predictions
pred_GGM_d<- predict(ggm1_d, newx=c(1:length(food_d_ts)))
pred_GGM_d<- ts(pred_GGM_d, start=start(food_d_ts), frequency = frequency(food_d_ts))
pred_GGM_d.inst<- make.instantaneous(pred_GGM_d)
pred_GGM_d.inst <- ts(pred_GGM_d.inst, start = start(food_d_ts), frequency=frequency(food_d_ts))
# plot
plot(food_d_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Daily Sales", main = "Actual vs Fitted Sales")
# Add the fitted values as a line
lines(pred_GGM_d.inst, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
###Analysis of residuals
res_GGM_f_d <- food_d_ts - pred_GGM_d.inst
tsdisplay(res_GGM_f_d)
# residuals have correlation and structure
# check for stationarity of residuals
adf_test <- adf.test(res_GGM_f_d) # H0: series is stationary
print(adf_test) # if p-val < alpha, series not stationary
# so with this model we dont achieve stationary series
# check for autocorrelation in residuals
Box.test(res_GGM_f_d, lag = 10, type = "Ljung-Box") # h0 res indep
# p-val < alpha =>  reject h0, so residuals are NOT indep
## 6.1.4 GGM BAR-------------
# Runs on DIMORA
# documentation: https://cran.rstudio.com/web/packages/DIMORA/DIMORA.pdf
# bass model preliminary m, p, q for algorithm
# mt argument is the determination of market potential
### Monthly----------------------------------
ggm1_bar_m <- GGM(bar_m_ts, mt = 'base', display = T)
ggm2_bar_m <- GGM(bar_m_ts, mt = function(x) pchisq(x, 10), display = T)
summary(ggm1_bar_m)
summary(ggm2_bar_m)
# Try different functions for market potential
ggm3_bar_m <- GGM(bar_m_ts, mt = function(x) log(x), display = T)
ggm4_bar_m <- GGM(bar_m_ts, mt = function(x) (x)^(1 / 1.05), display = T)
summary(ggm3_bar_m)
summary(ggm4_bar_m)
# Predictions
pred_GGM_bar_m <- predict(ggm1_bar_m, newx = c(1:length(bar_m_ts)))
pred_GGM_bar_m <- ts(pred_GGM_bar_m, start = start(bar_m_ts), frequency = frequency(bar_m_ts))
pred_GGM_bar_m.inst <- make.instantaneous(pred_GGM_bar_m)
pred_GGM_bar_m.inst <- ts(pred_GGM_bar_m.inst, start = start(bar_m_ts), frequency = frequency(bar_m_ts))
# Plot
plot(bar_m_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Monthly Sales", main = "Actual vs Fitted Sales (Bar)")
# Add the fitted values as a line
lines(pred_GGM_bar_m.inst, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Analysis of residuals
res_GGM_bar_m <- bar_m_ts - pred_GGM_bar_m.inst
tsdisplay(res_GGM_bar_m)
# Check for stationarity of residuals
adf_test_bar_m <- adf.test(res_GGM_bar_m)
print(adf_test_bar_m) # If p-val < alpha, series stationary
# Check for autocorrelation in residuals
Box.test(res_GGM_bar_m, lag = 10, type = "Ljung-Box") # h0 res indep
### Weekly----------------------------------
ggm1_bar_w <- GGM(bar_w_ts, mt = 'base', display = T)
ggm2_bar_w <- GGM(bar_w_ts, mt = function(x) pchisq(x, 25), display = T)
summary(ggm1_bar_w) # This one is better
summary(ggm2_bar_w)
# Try different functions for market potential
ggm3_bar_w <- GGM(bar_w_ts, mt = function(x) log(x), display = T)
ggm4_bar_w <- GGM(bar_w_ts, mt = function(x) (x)^(1 / 1.05), display = T)
summary(ggm3_bar_w)
summary(ggm4_bar_w) # Better shaped but less significant
# Predictions
pred_GGM_bar_w <- predict(ggm4_bar_w, newx = c(1:length(bar_w_ts)))
pred_GGM_bar_w <- ts(pred_GGM_bar_w, start = start(bar_w_ts), frequency = frequency(bar_w_ts))
pred_GGM_bar_w.inst <- make.instantaneous(pred_GGM_bar_w)
pred_GGM_bar_w.inst <- ts(pred_GGM_bar_w.inst, start = start(bar_w_ts), frequency = frequency(bar_w_ts))
# Plot
plot(bar_w_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Weekly Sales", main = "Actual vs Fitted Sales (Bar)")
# Add the fitted values as a line
lines(pred_GGM_bar_w.inst, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Analysis of residuals
res_GGM_bar_w <- bar_w_ts - pred_GGM_bar_w.inst
tsdisplay(res_GGM_bar_w)
# autocorrelation present
# Check for stationarity of residuals
adf_test_bar_w <- adf.test(res_GGM_bar_w)
print(adf_test_bar_w)
# not stationary, pval > alpha
# Check for autocorrelation in residuals
Box.test(res_GGM_bar_w, lag = 10, type = "Ljung-Box") # h0 res indep
# autocorrelation because pval < alpha (h0 no autocorrel, reject h0)
### Daily----------------------------------
ggm1_bar_d <- GGM(bar_d_ts, mt = 'base', display = T)
ggm2_bar_d <- GGM(bar_d_ts, mt = function(x) pchisq(x, 10), display = T)
summary(ggm1_bar_d) # This one is better looking / pc, qc non significant
summary(ggm2_bar_d)
# Try different functions for market potential
ggm3_bar_d <- GGM(bar_d_ts, mt = function(x) log(x), display = T)
ggm4_bar_d <- GGM(bar_d_ts, mt = function(x) (x)^(1 / 1.05), display = T)
summary(ggm3_bar_d)
summary(ggm1_bar_d)
summary(ggm4_bar_d)
# best model is the base one
# Predictions
pred_GGM_bar_d <- predict(ggm1_bar_d, newx = c(1:length(bar_d_ts)))
pred_GGM_bar_d <- ts(pred_GGM_bar_d, start = start(bar_d_ts), frequency = frequency(bar_d_ts))
pred_GGM_bar_d.inst <- make.instantaneous(pred_GGM_bar_d)
pred_GGM_bar_d.inst <- ts(pred_GGM_bar_d.inst, start = start(bar_d_ts), frequency = frequency(bar_d_ts))
# Plot
plot(bar_d_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Daily Sales", main = "Actual vs Fitted Sales (Bar)")
# Add the fitted values as a line
lines(pred_GGM_bar_d.inst, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Analysis of residuals
res_GGM_bar_d <- bar_d_ts - pred_GGM_bar_d.inst
tsdisplay(res_GGM_bar_d)
# serial autocorrel
# Check for stationarity of residuals
adf_test_bar_d <- adf.test(res_GGM_bar_d)
print(adf_test_bar_d)
# reject non stationarity: is stationary
# Check for autocorrelation in residuals
Box.test(res_GGM_bar_d, lag = 10, type = "Ljung-Box") # h0 res indep
# reject indep, there is correl
## 6.1.5 Holt-Winters FOOD---------------------
library(forecast)
# We try this model because fits trend and seasonality in a smooth way
#### Monthly------------------------------
autoplot(food_m_ts)
time(food_m_ts)
# adjust timeseries:
food_m_ts <- ts(food_m_ts, frequency=12, start=c(2021, 11))
hw1_m<- hw(food_m_ts, seasonal="additive")
hw2_m<- hw(food_m_ts, seasonal="multiplicative")
# prediction
fitted_hw1 <- hw1_m$fitted
fitted_hw2 <- hw2_m$fitted
# plot
# Create a data frame for ggplot
plot_data <- data.frame(
Time = time(food_m_ts),
Actual = as.numeric(food_m_ts),
Fitted_Additive = as.numeric(hw1_m$fitted),
Fitted_Multiplicative = as.numeric(hw2_m$fitted)
)
# Melt data for easier ggplot usage
library(reshape2)
plot_data_melted <- melt(plot_data, id.vars = "Time",
variable.name = "Series",
value.name = "Value")
# Plot using ggplot2
ggplot(plot_data_melted, aes(x = Time, y = Value, color = Series)) +
geom_point(data = subset(plot_data_melted, Series == "Actual"), size = 2) + # Actual values as dots
geom_line(data = subset(plot_data_melted, Series != "Actual"), size = 1) +  # Fitted values as lines
labs(
title = "Actual vs Fitted Values",
x = "Time",
y = "Value",
color = "Series"
) +
scale_color_manual(
values = c("Actual" = "black", "Fitted_Additive" = "blue", "Fitted_Multiplicative" = "red"),
labels = c("Actual", "Fitted (Additive)", "Fitted (Multiplicative)")
) +
theme_minimal() +
theme(
legend.position = "top",
legend.title = element_text(face = "bold")
)
# residuals
residuals_hw1 <- residuals(hw1_m)
residuals_hw2 <- residuals(hw2_m)
tsdisplay(residuals_hw1)
tsdisplay(residuals_hw2)
# Stationarity and Correlation
# check for stationarity of residuals
# additive
adf_test <- adf.test(residuals_hw1) # H0: series is non-stationary
print(adf_test) # if p-val < alpha, series not stationary
# so with this model we achieve stationary series
# multiplicative
adf_test <- adf.test(residuals_hw2) # H0: series is non-stationary
print(adf_test) # if p-val < alpha, series not stationary
# so with this model we achieve stationary series
# additive
# check for autocorrelation in residuals
Box.test(residuals_hw1, lag = 10, type = "Ljung-Box") # h0 res indep
# p-val > alpha =>  Dont reject h0, so residuals are indep
# additive
# check for autocorrelation in residuals
Box.test(residuals_hw2, lag = 10, type = "Ljung-Box") # h0 res indep
# p-val > alpha =>  Dont reject h0, so residuals are indep
# Model Multiplicative follows the data better,
# and residuals are slightly better
# forecast
# save the forecast of the second model
forecast_hw1 <- forecast(hw1_m, h=12)
forecast_hw2 <- forecast(hw2_m, h=12)
# Forecast plot
# Plot the time series with both forecasts
autoplot(food_m_ts) +
autolayer(forecast_hw1$mean, series="Additive Holt-Winters Forecast", PI=F) +
autolayer(forecast_hw2$mean, series="Multiplicative Holt-Winters Forecast", PI=F) +
ggtitle("Sales Forecast with Holt-Winters Models") +
xlab("Time") +
ylab("Sales") +
scale_color_manual(
values=c("Additive Holt-Winters Forecast" = "blue",
"Multiplicative Holt-Winters Forecast" = "red")
) +
theme_minimal() +
theme(legend.position = "top", legend.title = element_blank())
# autoplot
autoplot(food_m_ts)+
autolayer(hw2_m, series="Holt-Winters' method", PI=F)
## 6.1.6 Holt-Winters BAR---------------------
#### Monthly------------------------------
autoplot(bar_m_ts)
time(bar_m_ts)
# Adjust timeseries:
bar_m_ts <- ts(bar_m_ts, frequency = 12, start = c(2021, 11))
# Fit Holt-Winters models for bar data
hw1_b_m <- hw(bar_m_ts, seasonal = "additive")
hw2_b_m <- hw(bar_m_ts, seasonal = "multiplicative")
# Predictions
fitted_hw1_b_m <- hw1_b_m$fitted
fitted_hw2_b_m <- hw2_b_m$fitted
# Plot
# Create a data frame for ggplot
plot_data_b <- data.frame(
Time = time(bar_m_ts),
Actual = as.numeric(bar_m_ts),
Fitted_Additive = as.numeric(hw1_b_m$fitted),
Fitted_Multiplicative = as.numeric(hw2_b_m$fitted)
)
# Melt data for easier ggplot usage
plot_data_b_melted <- melt(plot_data_b, id.vars = "Time",
variable.name = "Series",
value.name = "Value")
# Plot using ggplot2
ggplot(plot_data_b_melted, aes(x = Time, y = Value, color = Series)) +
geom_point(data = subset(plot_data_b_melted, Series == "Actual"), size = 2) + # Actual values as dots
geom_line(data = subset(plot_data_b_melted, Series != "Actual"), size = 1) +  # Fitted values as lines
labs(
title = "Actual vs Fitted Values (Bar)",
x = "Time",
y = "Value",
color = "Series"
) +
scale_color_manual(
values = c("Actual" = "black", "Fitted_Additive" = "blue", "Fitted_Multiplicative" = "red"),
labels = c("Actual", "Fitted (Additive)", "Fitted (Multiplicative)")
) +
theme_minimal() +
theme(
legend.position = "top",
legend.title = element_text(face = "bold")
)
# Residuals
residuals_hw1_b_m <- residuals(hw1_b_m)
residuals_hw2_b_m <- residuals(hw2_b_m)
tsdisplay(residuals_hw1_b_m, main = "Residuals: Additive Holt-Winters (Bar)")
tsdisplay(residuals_hw2_b_m, main = "Residuals: Multiplicative Holt-Winters (Bar)")
# Stationarity and Correlation
# Check for stationarity of residuals
# Additive
adf_test_hw1_b_m <- adf.test(residuals_hw1_b_m) # H0: series is non-stationary
print(adf_test_hw1_b_m) # If p-val < alpha, series is stationary
# Multiplicative
adf_test_hw2_b_m <- adf.test(residuals_hw2_b_m) # H0: series is non-stationary
print(adf_test_hw2_b_m) # If p-val < alpha, series is stationary
# Check for autocorrelation in residuals
# Additive
Box.test(residuals_hw1_b_m, lag = 10, type = "Ljung-Box") # H0: residuals are independent
# Multiplicative
Box.test(residuals_hw2_b_m, lag = 10, type = "Ljung-Box") # H0: residuals are independent
# Multiplicative model seems to follow the data better,
# and residuals are slightly better
# Forecast
# Save the forecast of the two models
forecast_hw1_b_m <- forecast(hw1_b_m, h = 12)
forecast_hw2_b_m <- forecast(hw2_b_m, h = 12)
# Forecast plot
# Plot the time series with both forecasts
autoplot(bar_m_ts) +
autolayer(forecast_hw1_b_m$mean, series = "Additive Holt-Winters Forecast (Bar)", PI = F) +
autolayer(forecast_hw2_b_m$mean, series = "Multiplicative Holt-Winters Forecast (Bar)", PI = F) +
ggtitle("Sales Forecast with Holt-Winters Models (Bar)") +
xlab("Time") +
ylab("Sales") +
scale_color_manual(
values = c("Additive Holt-Winters Forecast (Bar)" = "blue",
"Multiplicative Holt-Winters Forecast (Bar)" = "red")
) +
theme_minimal() +
theme(legend.position = "top", legend.title = element_blank())
# Autoplot
autoplot(bar_m_ts) +
autolayer(hw2_b_m, series = "Holt-Winters' Method (Multiplicative, Bar)", PI = F)
# 7. ARIMA Models----------------------------
## 7.1 Standard ARIMA FOOD---------------------------------
## Montly------------------
plot(food_m_ts)
# see if series is stationary
adf.test(food_m_ts) #H0, series is non-stationary
# p-val > 0.05 => dont reject, non stationary: series is not stationary
adf.test(diff(food_m_ts)) #H0, series is non-stationary
# see the acf and pacf
tsdisplay(diff(food_m_ts))
# PACF suggest AR-1 ?
# ACF suggests MA-1 ?
????
### Manual ARIMA------------
# ARIMA(p,d,q) = (1,1,0)
arima1_m<- Arima(food_m_ts, order=c(1,1,0))
### Manual ARIMA------------
# ARIMA(p,d,q) = (1,1,0)
arima1_m<- Arima(food_m_ts, order=c(1,1,0))
