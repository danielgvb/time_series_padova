print(model_stats_d)
# Calculate RMSE for each model on daily data
rmse_stats_d <- data.frame(
Model = character(),
RMSE = numeric(),
stringsAsFactors = FALSE
)
for (i in seq_along(models_d)) {
model_name <- names(models_d)[i]
predicted_column <- paste0("predicted_sales", i - 1) # Adjust index as per your data
rmse <- calculate_rmse(df_merged_d$sales_cop, df_merged_d[[predicted_column]])
rmse_stats_d <- rbind(rmse_stats_d, data.frame(Model = model_name, RMSE = rmse))
}
# View RMSE statistics for daily data
print(rmse_stats_d)
# 6 Non Linear Models----------------
# re-declare time-series beacause we droped some rows:
# Ensure the 'date' columns are in Date format
df_merged_d$date <- as.Date(df_merged_d$date)
df_merged_w$date <- as.Date(df_merged_w$week)
df_merged_m$date <- as.Date(df_merged_m$month)
# Extract the start date and year for each dataframe
start_d <- min(df_merged_d$date)
start_w <- min(df_merged_w$date)
start_m <- min(df_merged_m$date)
# Extract components for daily, weekly, and monthly start times
start_d_year <- as.numeric(format(start_d, "%Y"))
start_d_day <- as.numeric(format(start_d, "%j")) # Day of the year
start_w_year <- as.numeric(format(start_w, "%Y"))
start_w_week <- as.numeric(format(start_w, "%U")) + 1 # Week number, adding 1 since R starts at week 0
start_m_year <- as.numeric(format(start_m, "%Y"))
start_m_month <- as.numeric(format(start_m, "%m"))
# Declare time series with appropriate frequencies
sales_d_ts <- ts(exp(df_merged_d$sales_cop), start = c(start_d_year, start_d_day), frequency = 365)
sales_w_ts <- ts(exp(df_merged_w$sales_w), start = c(start_w_year, start_w_week), frequency = 52)
sales_m_ts <- ts(exp(df_merged_m$sales_m), start = c(start_m_year, start_m_month), frequency = 12)
food_d_ts <- ts(exp(df_merged_d$food), start = c(start_d_year, start_d_day), frequency = 365)
food_w_ts <- ts(exp(df_merged_w$food_w), start = c(start_w_year, start_w_week), frequency = 52)
food_m_ts <- ts(exp(df_merged_m$food_m), start = c(start_m_year, start_m_month), frequency = 12)
bar_d_ts <- ts(exp(df_merged_d$bar), start = c(start_d_year, start_d_day), frequency = 365)
bar_w_ts <- ts(exp(df_merged_w$bar_w), start = c(start_w_year, start_w_week), frequency = 52)
bar_m_ts <- ts(exp(df_merged_m$bar_m), start = c(start_m_year, start_m_month), frequency = 12)
# Verify the created time series
par(mfrow=c(1,1))
plot(sales_d_ts)
plot(sales_w_ts)
plot(sales_m_ts)
plot(food_d_ts)
plot(food_w_ts)
plot(food_m_ts)
plot(bar_d_ts)
plot(bar_w_ts)
plot(bar_m_ts)
# Function to replace 1s with the mean of previous and next observations
fill_ones <- function(ts_data) {
# Convert time series to numeric vector
ts_vec <- as.numeric(ts_data)
# Loop through and replace 1s
for (i in seq_along(ts_vec)) {
if (ts_vec[i] == 1) {
# Check boundaries to avoid indexing issues
prev_val <- ifelse(i > 1, ts_vec[i - 1], NA)
next_val <- ifelse(i < length(ts_vec), ts_vec[i + 1], NA)
# Replace with mean of previous and next, ignoring NA
ts_vec[i] <- mean(c(prev_val, next_val), na.rm = TRUE)
}
}
# Return as time series with original attributes
ts(ts_vec, start = start(ts_data), frequency = frequency(ts_data))
}
# Apply the function
sales_d_ts <- fill_ones(sales_d_ts)
sales_w_ts <- fill_ones(sales_w_ts)
sales_m_ts <- fill_ones(sales_m_ts)
food_d_ts <- fill_ones(food_d_ts)
food_w_ts <- fill_ones(food_w_ts)
food_m_ts <- fill_ones(food_m_ts)
bar_d_ts <- fill_ones(bar_d_ts)
bar_w_ts <- fill_ones(bar_w_ts)
bar_m_ts <- fill_ones(bar_m_ts)
## 6.1 Difussion Models----------------
## 6.1.1 BASS Model--------------
### Monthly---------
# simple Bass model
bm_m<-BM(sales_m_ts,display = T) # show graphical view of results / display = True
summary(bm_m)
bm_m$coefficients['m'] - sum(sales_m_ts)
# according to this, there are only 1m cop left to sell, this is less than a year / seems wrong
# Fits well but the 30- onward is wierd + sales might not be declining yet
# Still reflects the innovation and copying in some sense
# Also the restaurants rely in word of mouth to reach full stage
# m = 4.664.000.000 COP, i.e 1 mm EUR approx. / The restaurant has sold 3.515.788.885
# according to this only in 1 year it should extinguish sells
# p, innovation: 0.832% indicates that the adoption rate due to external
# influence is relatively low, but not uncommon for many markets. - it is actually relativly innovative
# q: (8.96%) suggests that imitation plays a larger role than
# innovation in driving adoption in this market
# Prediction
pred_bm_m<- predict(bm_m, newx=c(1:length(sales_m_ts)))
pred_bm_m <- ts(pred_bm_m, start = start(sales_m_ts), frequency = frequency(sales_m_ts))
pred.inst_bm_m <- make.instantaneous(pred_bm_m)
pred.inst_bm_m <- ts(pred.inst_bm_m, start = start(sales_m_ts), frequency = frequency(sales_m_ts))
# plot
plot(sales_m_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Monthly Sales", main = "Actual vs Fitted Sales")
# Add the fitted values as a line
lines(pred.inst_bm_m, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# check residuals
res_bm_m <- sales_m_ts - pred.inst_bm_m
tsdisplay(res_bm_m)
# residuals have some structure and 2 lag has correl
# RMSE
# Calculate RMSE for Bass Model predictions
rmse_bm_m <- calculate_rmse(observed = sales_m_ts, predicted = pred.inst_bm_m)
# Print the RMSE
cat("RMSE for Bass Model Predictions:", rmse_bm_m, "\n")
### Weekly------------------------------------------------
bm_w<-BM(sales_w_ts,display = T) # show graphical view of results / display = True
summary(bm_w)
bm_w$coefficients['m'] - sum(sales_w_ts)
# results are similar in terms of m, p and w are in other scale
#because they are in different time stamp
bm_m$coefficients['q'] / bm_w$coefficients['q'] # they are approx 4 times
bm_m$coefficients['p'] / bm_w$coefficients['p'] # they are approx 4 times
# which makes sense
# Prediction
pred_bm_w<- predict(bm_w, newx=c(1:length(sales_w_ts)))
pred_bm_w <- ts(pred_bm_w, start = start(sales_w_ts), frequency = frequency(sales_w_ts))
pred.inst_bm_w <- make.instantaneous(pred_bm_w)
pred.inst_bm_w <- ts(pred.inst_bm_w, start = start(sales_w_ts), frequency = frequency(sales_w_ts))
# plot
plot(sales_w_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Week", ylab = "Weekly Sales", main = "Actual vs Fitted Sales")
# Add the fitted values as a line
lines(pred.inst_bm_w, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# check residuals
res_bm_w <- sales_w_ts - pred.inst_bm_w
tsdisplay(res_bm_w)
# residuals have some structure and 2 lag has correl
# clear trend and structure in the residuals
# RMSE
# Calculate RMSE for Bass Model predictions
rmse_bm_w <- calculate_rmse(observed = sales_w_ts, predicted = pred.inst_bm_w)
# Print the RMSE
cat("RMSE for Bass Model Predictions:", rmse_bm_w, "\n")
### Daily--------------------------------------
bm_d <- BM(
sales_d_ts,
prelimestimates = c(1.2 * sum(sales_d_ts), 0.005, 0.5), # Adjust these estimates
display = TRUE
)
summary(bm_d)
bm_d$coefficients['m'] - sum(sales_d_ts)
# results are similar in terms of m, p and w are in other scale
#because they are in different time stamp
bm_w$coefficients['q'] / bm_d$coefficients['q'] # they are approx 7 times
bm_w$coefficients['p'] / bm_d$coefficients['p'] # they are approx 7 times
# which makes sense
# Prediction
pred_bm_d <- predict(bm_d, newx = c(1:length(sales_d_ts)))
pred_bm_d <- ts(pred_bm_d, start = start(sales_d_ts), frequency = frequency(sales_d_ts))
pred.inst_bm_d <- make.instantaneous(pred_bm_d)
pred.inst_bm_d <- ts(pred.inst_bm_d, start = start(sales_d_ts), frequency = frequency(sales_d_ts))
# Plot actual vs fitted sales for daily data
plot(sales_d_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Day", ylab = "Daily Sales", main = "Actual vs Fitted Sales (Daily)")
# Add the fitted values as a line
lines(pred.inst_bm_d, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Check residuals
res_bm_d <- sales_d_ts - pred.inst_bm_d
tsdisplay(res_bm_d)
# Note: Review residual plots for any trends or structures.
# Calculate RMSE for Bass Model predictions (daily data)
rmse_bm_d <- calculate_rmse(observed = sales_d_ts, predicted = pred.inst_bm_d)
# Print the RMSE
cat("RMSE for Daily Bass Model Predictions:", rmse_bm_d, "\n")
# overall the bass model fits a bell, if we are doing a generalized version
# lets try one that lets us define a more versatile curve
## 6.1.2 GGM-------------
# Runs on DIMORA
# documentation: https://cran.rstudio.com/web/packages/DIMORA/DIMORA.pdf
# bass model preliminary m, p, q for algorithm
# mt argument is the determination of market potential
### Monthly----------------------------------
ggm1 <- GGM(sales_m_ts, mt='base', display = T)
ggm2 <- GGM(sales_m_ts, mt= function(x) pchisq(x,10),display = T)
summary(ggm1)
summary(ggm2)
# try different functions for market potential
ggm3 <- GGM(sales_m_ts, mt= function(x) log(x),display = T)
ggm4 <- GGM(sales_m_ts, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3)
summary(ggm4)
# predictions
# Prediction using GGM model (example with ggm1)
pred_ggm_m <- predict(ggm1, newx = c(1:length(sales_m_ts)))
pred_ggm_m <- ts(pred_ggm_m, start = start(sales_m_ts), frequency = frequency(sales_m_ts))
pred.inst_ggm_m <- make.instantaneous(pred_ggm_m)
pred.inst_ggm_m <- ts(pred.inst_ggm_m, start = start(sales_m_ts), frequency = frequency(sales_m_ts))
# Plot actual vs fitted sales for monthly data
plot(sales_m_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Monthly Sales", main = "Actual vs Fitted Sales (GGM Model)")
# Add the fitted values as a line
lines(pred.inst_ggm_m, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values (GGM)"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
###Analysis of residuals
res_GGM_m<- sales_m_ts - pred.inst_ggm_m
pred_GGM_m
# mt argument is the determination of market potential
### Monthly----------------------------------
ggm1 <- GGM(sales_m_ts, mt='base', display = T)
ggm2 <- GGM(sales_m_ts, mt= function(x) pchisq(x,10),display = T)
summary(ggm1)
summary(ggm2)
ggm3 <- GGM(sales_m_ts, mt= function(x) log(x),display = T)
ggm4 <- GGM(sales_m_ts, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3)
summary(ggm4)
# Prediction using GGM model (example with ggm1)
pred_ggm_m <- predict(ggm1, newx = c(1:length(sales_m_ts)))
pred_ggm_m <- ts(pred_ggm_m, start = start(sales_m_ts), frequency = frequency(sales_m_ts))
pred.inst_ggm_m <- make.instantaneous(pred_ggm_m)
pred.inst_ggm_m <- ts(pred.inst_ggm_m, start = start(sales_m_ts), frequency = frequency(sales_m_ts))
# Plot actual vs fitted sales for monthly data
plot(sales_m_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Month", ylab = "Monthly Sales", main = "Actual vs Fitted Sales (GGM Model)")
# Add the fitted values as a line
lines(pred.inst_ggm_m, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values (GGM)"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
###Analysis of residuals
res_GGM_m<- sales_m_ts - pred.inst_ggm_m
pred_GGM_m
###Analysis of residuals
res_GGM_m<- sales_m_ts - pred.inst_ggm_m
tsdisplay(res_GGM_m)
plot(c(1:length(res_GGM_m)),res_GGM_m)
# Residuals somehow are kind of stationary
# check for stationarity of residuals
adf_test <- adf.test(res_GGM_m)
print(adf_test) # if p-val < alpha, series stationary
# check for autocorrelation in residuals
Box.test(res_GGM_m, lag = 10, type = "Ljung-Box") # h0 res indep
### Weekly----------------------------------
ggm1_w <- GGM(sales_w_ts, mt='base', display = T)
summary(ggm1_w) # this one is better
summary(ggm2_w)
### Weekly----------------------------------
ggm1_w <- GGM(sales_w_ts, mt='base', display = T)
ggm2_w <- GGM(sales_w_ts, mt= function(x) pchisq(x,25),display = T)
summary(ggm1_w) # this one is better
summary(ggm2_w)
ggm3_w <- GGM(sales_w_ts, mt= function(x) log(x),display = T)
ggm4_w <- GGM(sales_w_ts, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3_w)
summary(ggm4_w) # better shaped but less significant
pred_ggm_w <- predict(ggm1_w, newx = c(1:length(sales_w_ts)))
pred_ggm_w <- ts(pred_ggm_w, start = start(sales_w_ts), frequency = frequency(sales_w_ts))
pred.inst_ggm_w <- make.instantaneous(pred_ggm_w)
pred.inst_ggm_w <- ts(pred.inst_ggm_w, start = start(sales_w_ts), frequency = frequency(sales_w_ts))
# Plot actual vs fitted sales for weekly data
plot(sales_w_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Week", ylab = "Weekly Sales", main = "Actual vs Fitted Sales (GGM Model)")
# Add the fitted values as a line
lines(pred.inst_ggm_w, col = "red", lwd = 2)
# Add a legend
legend("topleft", legend = c("Actual Values", "Fitted Values (GGM)"),
col = c("black", "red"), pch = c(16, NA), lty = c(NA, 1), lwd = c(NA, 2))
# Analysis of residuals
res_GGM_w <- sales_w_ts - pred.inst_ggm_w
tsdisplay(res_GGM_w)
# Check for stationarity of residuals
adf_test_w <- adf.test(res_GGM_w)
print(adf_test_w) # if p-value < alpha, series is stationary
# Check for autocorrelation in residuals
box_test_w <- Box.test(res_GGM_w, lag = 10, type = "Ljung-Box")
print(box_test_w) # if p-value > alpha, residuals are independent
# Calculate RMSE for GGM model predictions (weekly data)
rmse_ggm_w <- calculate_rmse(observed = sales_w_ts, predicted = pred.inst_ggm_w)
# Print the RMSE
cat("RMSE for Weekly GGM Model Predictions:", rmse_ggm_w, "\n")
sales_test <- ts(df_merged_d$sales_cop)
ggm1_test <- GGM(sales_test, mt='base', display = T)
tsplot(sales_test)
plot(sales_test)
ggm1_d <- GGM(sales_d_ts, mt='base', display = T)
ggm1_d <- GGM(sales_d_ts, mt='base', display = T)
### Daily----------------------------------
library(DIMORA)
ggm1_d <- GGM(sales_d_ts, mt='base', display = T)
ggm1_d <- GGM(sales_d_ts, mt='base', display = T)
ggm1_d <- GGM(
sales_d_ts,
mt = 'base',
prelimestimates = c(1.2 * sum(sales_d_ts), 0.01, 0.3),
trace = TRUE,
display = T
)
ggm1_d <- GGM(
sales_d_ts,
mt = 'base',
prelimestimates = c(1.2 * sum(sales_d_ts), 0.01, 0.3),
display = T
)
# Z-Score Standardization
sales_mean <- mean(sales_d_ts)
sales_sd <- sd(sales_d_ts)
sales_scaled <- (sales_d_ts - sales_mean) / sales_sd
# View scaled data
summary(sales_scaled)
ggm1_test <- GGM(sales_scaled, mt='base', display = T)
sales_min <- min(sales_d_ts)
sales_max <- max(sales_d_ts)
sales_scaled <- (sales_d_ts - sales_min) / (sales_max - sales_min)
# View scaled data
summary(sales_scaled)
# View scaled data
summary(sales_scaled)
plot(sales_scaled)
ggm1_d <- GGM(sales_scaled, mt='base', display = T)
sales_min <- min(sales_d_ts)
sales_max <- max(sales_d_ts)
sales_scaled <- (sales_d_ts - sales_min) / (sales_max - sales_min)
# View scaled data
summary(sales_scaled)
plot(sales_scaled)
ggm1_d <- GGM(sales_scaled, mt='base', display = T)
ggm1_d <- GGM(sales_scaled, mt='base', display = T)
ggm2_d <- GGM(sales_scaled, mt= function(x) pchisq(x,10),display = T)
summary(ggm1_d) # this one is better looking
summary(ggm2_d)
summary(ggm1_d) # this one is better looking
ggm3_d <- GGM(sales_scaled, mt= function(x) log(x),display = T)
ggm4_d <- GGM(sales_scaled, mt= function(x) (x)**(1/1.05),display = T)
summary(ggm3_d)
summary(ggm1_d)
summary(ggm4_d) # better shaped and still significant
summary(ggm1_d)
ggm1_d <- GGM(sales_scaled, mt='base', display = T)
summary(ggm1_d) # better shaped
# Scaling the sales data
sales_min <- min(sales_d_ts)
sales_max <- max(sales_d_ts)
sales_scaled <- (sales_d_ts - sales_min) / (sales_max - sales_min)
# View scaled data
summary(sales_scaled)
plot(sales_scaled, type = "l", col = "blue", main = "Scaled Daily Sales", xlab = "Day", ylab = "Scaled Sales")
plot(sales_scaled, type = "l", main = "Scaled Daily Sales", xlab = "Day", ylab = "Scaled Sales")
# Fit GGM models using scaled data
ggm1_d <- GGM(sales_scaled, mt = 'base', display = T)
ggm2_d <- GGM(sales_scaled, mt = function(x) pchisq(x, 10), display = T)
ggm3_d <- GGM(sales_scaled, mt = function(x) log(x), display = T)
ggm4_d <- GGM(sales_scaled, mt = function(x) (x)^(1/1.05), display = T)
# Summarize models
summary(ggm1_d)  # Base model
summary(ggm2_d)  # Chi-squared
summary(ggm3_d)  # Log transformation
summary(ggm4_d)  # Power transformation
# Select the best model (example: ggm1_d)
# Prediction using GGM model
pred_ggm_d <- predict(ggm1_d, newx = c(1:length(sales_scaled)))
pred_ggm_d <- ts(pred_ggm_d, start = start(sales_scaled), frequency = frequency(sales_scaled))
pred.inst_ggm_d <- make.instantaneous(pred_ggm_d)
pred.inst_ggm_d <- ts(pred.inst_ggm_d, start = start(sales_scaled), frequency = frequency(sales_scaled))
# Re-scale predictions back to the original scale
pred_original_scale <- (pred.inst_ggm_d * (sales_max - sales_min)) + sales_min
# Plot actual vs fitted sales (original scale)
plot(sales_d_ts, type = "p", col = "black", pch = 16, cex = 0.7,
xlab = "Day", ylab = "Daily Sales", main = "Actual vs Fitted Sales (Original Scale)")
lines(pred_original_scale, col = "red", lwd = 2)
# Analysis of residuals
res_GGM_d <- sales_d_ts - pred_original_scale
tsdisplay(res_GGM_d, main = "Residuals of GGM Model")
# Check for stationarity of residuals
adf_test_d <- adf.test(res_GGM_d)
print(adf_test_d)  # If p-value < alpha, series is stationary
# Check for autocorrelation in residuals
box_test_d <- Box.test(res_GGM_d, lag = 10, type = "Ljung-Box")
print(box_test_d)  # If p-value > alpha, residuals are independent
# Calculate RMSE for GGM model predictions (original scale)
rmse_original <- calculate_rmse(observed = sales_d_ts, predicted = pred_original_scale)
# Print the RMSE
cat("RMSE for Daily GGM Model Predictions (Original Scale):", rmse_original, "\n")
## 6.1.3 Holt-Winters---------------------
library(forecast)
# We try this model because fits trend and seasonality in a smooth way
#### Monthly------------------------------
autoplot(sales_m_ts)
# adjust timeseries:
sales_m_ts <- ts(sales_m_ts, frequency=12, start=c(2021, 11))
hw1_m<- hw(sales_m_ts, seasonal="additive")
hw2_m<- hw(sales_m_ts, seasonal="multiplicative")
# prediction
fitted_hw1 <- hw1_m$fitted
fitted_hw2 <- hw2_m$fitted
# Create a data frame for ggplot
plot_data <- data.frame(
Time = time(sales_m_ts),
Actual = as.numeric(sales_m_ts),
Fitted_Additive = as.numeric(hw1_m$fitted),
Fitted_Multiplicative = as.numeric(hw2_m$fitted)
)
# Melt data for easier ggplot usage
library(reshape2)
plot_data_melted <- melt(plot_data, id.vars = "Time",
variable.name = "Series",
value.name = "Value")
# Plot using ggplot2
ggplot(plot_data_melted, aes(x = Time, y = Value, color = Series)) +
geom_point(data = subset(plot_data_melted, Series == "Actual"), size = 2) + # Actual values as dots
geom_line(data = subset(plot_data_melted, Series != "Actual"), size = 1) +  # Fitted values as lines
labs(
title = "Actual vs Fitted Values",
x = "Time",
y = "Value",
color = "Series"
) +
scale_color_manual(
values = c("Actual" = "black", "Fitted_Additive" = "blue", "Fitted_Multiplicative" = "red"),
labels = c("Actual", "Fitted (Additive)", "Fitted (Multiplicative)")
) +
theme_minimal() +
theme(
legend.position = "top",
legend.title = element_text(face = "bold")
)
# residuals
residuals_hw1 <- residuals(hw1_m)
residuals_hw2 <- residuals(hw2_m)
tsdisplay(residuals_hw1)
tsdisplay(residuals_hw2)
# Stationarity and Correlation
# check for stationarity of residuals
# additive
adf_test <- adf.test(residuals_hw1) # H0: series is non-stationary
print(adf_test) # if p-val < alpha, series not stationary
# so with this model we achieve stationary series
# multiplicative
adf_test <- adf.test(residuals_hw2) # H0: series is non-stationary
print(adf_test) # if p-val < alpha, series not stationary
# additive
# check for autocorrelation in residuals
Box.test(residuals_hw1, lag = 10, type = "Ljung-Box") # h0 res indep
# additive
# check for autocorrelation in residuals
Box.test(residuals_hw2, lag = 10, type = "Ljung-Box") # h0 res indep
# Forecast plot
# Plot the time series with both forecasts
autoplot(sales_m_ts) +
autolayer(forecast_hw1$mean, series="Additive Holt-Winters Forecast", PI=F) +
autolayer(forecast_hw2$mean, series="Multiplicative Holt-Winters Forecast", PI=F) +
ggtitle("Sales Forecast with Holt-Winters Models") +
xlab("Time") +
ylab("Sales") +
scale_color_manual(
values=c("Additive Holt-Winters Forecast" = "blue",
"Multiplicative Holt-Winters Forecast" = "red")
) +
theme_minimal() +
theme(legend.position = "top", legend.title = element_blank())
# forecast
# save the forecast of the second model
forecast_hw1 <- forecast(hw1_m, h=12)
forecast_hw2 <- forecast(hw2_m, h=12)
# Forecast plot
# Plot the time series with both forecasts
autoplot(sales_m_ts) +
autolayer(forecast_hw1$mean, series="Additive Holt-Winters Forecast", PI=F) +
autolayer(forecast_hw2$mean, series="Multiplicative Holt-Winters Forecast", PI=F) +
ggtitle("Sales Forecast with Holt-Winters Models") +
xlab("Time") +
ylab("Sales") +
scale_color_manual(
values=c("Additive Holt-Winters Forecast" = "blue",
"Multiplicative Holt-Winters Forecast" = "red")
) +
theme_minimal() +
theme(legend.position = "top", legend.title = element_blank())
# autoplot
autoplot(sales_m_ts)+
autolayer(hw2_m, series="Holt-Winters' method", PI=F)
# RMSE
# RMSE Calculation for Holt-Winters models
rmse_hw1 <- calculate_rmse(observed = sales_m_ts, predicted = fitted_hw1)
rmse_hw2 <- calculate_rmse(observed = sales_m_ts, predicted = fitted_hw2)
# Print RMSE values
cat("RMSE for Additive Holt-Winters Model:", rmse_hw1, "\n")
cat("RMSE for Multiplicative Holt-Winters Model:", rmse_hw2, "\n")
#### Weekly------------------------------
tsdisplay(sales_m_ts)
autoplot(sales_w_ts)
head(df_merged_w)
head(sales_w_ts)
# adjust timeseries:
sales_w_ts <- ts(sales_w_ts, frequency=52, start=c(2021, 10,31))
plot(sales_m_ts)
# see if series is stationary
adf.test(sales_m_ts) #H0, series is non-stationary
# p-val > 0.05 => dont reject, non stationary: series is not stationary
adf.test(diff(sales_m_ts)) #H0, series is non-stationary
